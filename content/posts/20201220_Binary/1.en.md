---
title: "Python program for exponentiation calculation using binary method"
date: 2020-12-20T15:17:23+09:00
draft: false
tags: ["algorithm"] 
---
<!--more-->
# Binary Exponentiation (Modular Exponentiation) in Python

## Binary Exponentiation Method

Calculating $a^k$ by direct multiplication requires $k$ multiplications. However, when $k$ is a very large number, this becomes computationally expensive and impractical. The **binary exponentiation method** (also known as **exponentiation by squaring** or **modular exponentiation**) is an efficient algorithm to compute $a^k \pmod{p}$ (the remainder when $a^k$ is divided by $p$). This method significantly reduces the number of multiplications to $O(\log k)$. It is crucial for cryptographic algorithms like RSA, where exponents can be extremely large.

The core idea is to express the exponent $k$ in its binary representation. For example, to calculate $5^{21} \pmod{p}$:

First, convert the exponent $21$ to binary:
$21 = 16 + 4 + 1 = 1 \cdot 2^4 + 0 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0$
So, the binary representation of $21$ is $(10101)_2$.

Then, $5^{21}$ can be decomposed as:
$
5^{21} = 5^{16} \cdot 5^4 \cdot 5^1
$
We can pre-calculate powers of $a$ that are powers of two (i.e., $a^1, a^2, a^4, a^8, a^{16}, \dots$) by repeatedly squaring the previous result. Then, we only multiply the terms corresponding to the '1' bits in the binary representation of the exponent. This drastically reduces the number of multiplications.

## Python Implementation

The following Python program implements the binary exponentiation method (right-to-left approach) to efficiently calculate $(base^{exp}) \pmod{mod}$:

```python:binary_exponentiation.py
def power(base, exp, mod):
    """
    Efficiently calculates (base^exp) % mod using the binary exponentiation method.

    :param base: The base number.
    :param exp: The exponent.
    :param mod: The modulus.
    :return: The result of (base^exp) % mod.
    """
    res = 1
    base %= mod  # Ensure base is within the modulo range
    while exp > 0:
        # If the last bit of exp is 1, multiply res by base
        if exp % 2 == 1:
            res = (res * base) % mod
        
        # Square the base and take modulo
        base = (base * base) % mod
        # Right shift exp by 1 bit (integer division by 2)
        exp //= 2
        
    return res

# --- Examples ---
# Calculate 5^21 mod 99
k = 21
g = 5
p = 99
result = power(g, k, p)
print(f"{g}^{k} mod {p} = {result}") # Expected Output: 5^21 mod 99 = 20

# Example with large numbers
k = 12345678901234567890
g = 987654321987654321
p = 1000000007
result = power(g, k, p)
print(f"Result for large numbers: {result}")
```

### Program Explanation
1.  `res = 1`: Initializes the result variable to 1.
2.  `base %= mod`: Ensures that the base is always kept within the modulo range, preventing intermediate numbers from becoming too large.
3.  `while exp > 0:`: The loop continues as long as the exponent `exp` is greater than 0.
4.  `if exp % 2 == 1:`: Checks if the least significant bit (LSB) of `exp` is 1. If it is, it means this power of 2 is part of the exponent, so `res` is multiplied by the current `base`.
5.  `base = (base * base) % mod`: The `base` is squared in each iteration. This effectively calculates $a^1, a^2, a^4, a^8, \dots$ (modulo $p$).
6.  `exp //= 2`: The exponent `exp` is right-shifted by 1 bit (integer division by 2). This moves to the next bit of the exponent in the binary representation.
7.  When the loop finishes, `res` holds the final calculated modular exponentiation result.

This method ensures that intermediate calculations do not exceed the modulus, allowing for fast and memory-efficient computation of large modular exponentiations.
