---
title: "ユークリッドの互除法と拡張ユークリッドの互除法（Python実装）"
date: 2020-10-15T15:17:23+09:00
draft: false
tags: ["アルゴリズム", "Python"]
---<!--more--># ユークリッドの互除法と拡張ユークリッドの互除法（Python実装）## ユークリッドの互除法### 概要ユークリッドの互除法は、2つの自然数 $a$ と $b$ の**最大公約数 (Greatest Common Divisor, GCD)** を効率的に求めるアルゴリズムです。その原理は、「$a$ を $b$ で割った余りを $r$ とすると、$a$ と $b$ の最大公約数は、$b$ と $r$ の最大公約数に等しい」という性質に基づいています。つまり、`gcd(a, b) = gcd(b, a % b)` が成り立ちます。これを、余りが0になるまで再帰的に繰り返すことで、最終的な最大公約数が得られます。### アルゴリズム1.  入力として2つの自然数 $a, b$ ($a \ge b$) を受け取る。2.  $b$ が 0 ならば、$a$ が最大公約数である。3.  $b$ が 0 でなければ、$a$ を $b$ で割った余り $r$ を計算する。4.  $a$ に $b$ を、$b$ に $r$ を代入し、ステップ2に戻る。### Pythonによる実装アルゴリズムをシンプルに実装できます。#### 再帰関数による実装```python:euclid_recursive.pydef gcd_recursive(a, b):    """再帰関数を用いて最大公約数を求める"""    if b == 0:        return a    else:        return gcd_recursive(b, a % b)# 例print(gcd_recursive(54, 20)) # -> 2print(gcd_recursive(111, 30)) # -> 3```#### ループによる実装```python:euclid_iterative.pydef gcd_iterative(a, b):    """ループを用いて最大公約数を求める"""    while b:        a, b = b, a % b    return a# 例print(gcd_iterative(54, 20)) # -> 2print(gcd_iterative(111, 30)) # -> 3```---## 拡張ユークリッドの互除法### 概要拡張ユークリッドの互除法は、ユークリッドの互除法を拡張したもので、2つの整数 $a, b$ の最大公約数 $d = \text{gcd}(a, b)$ を求めると同時に、次の一不定方程式（ベズーの等式）を満たす整数解 $(x, y)$ を見つけるアルゴリズムです。$$ax + by = \text{gcd}(a, b)$$このアルゴリズムは、RSA暗号における逆元の計算などで広く利用されています。### アルゴリズムユークリッドの互除法の計算過程を逆にたどることで、係数 $x, y$ を求めることができます。$a_0 = a, a_1 = b$ とし、互除法の計算過程を$a_{i-1} = q_i a_i + a_{i+1}$とします。この式を繰り返し変形していくと、$x, y$ が求められます。再帰的なアルゴリズムで実装するのが一般的です。ベースケースは $b=0$ のときで、$\text{gcd}(a, 0) = a$ なので、$a \cdot 1 + 0 \cdot 0 = a$ となり、解は $(x, y) = (1, 0)$ です。再帰ステップでは、`gcd(b, a % b)` の結果を利用して `gcd(a, b)` の解を構成します。`b * x' + (a % b) * y' = gcd(b, a % b)`となる $x', y'$ が分かっているとすると、`a % b = a - (a // b) * b` なので、`b * x' + (a - (a // b) * b) * y' = gcd(a, b)``a * y' + b * (x' - (a // b) * y') = gcd(a, b)`となり、元の式の解は $(x, y) = (y', x' - (a // b) * y')$ となります。### Pythonによる実装```python:extended_euclid.pydef extended_gcd(a, b):    """    拡張ユークリッドの互除法を用いて、ax + by = gcd(a, b) を満たす    (gcd, x, y) のタプルを返す。    """    if b == 0:        return a, 1, 0    else:        d, x, y = extended_gcd(b, a % b)        return d, y, x - (a // b) * y# 例: 54x + 20y = gcd(54, 20) = 2d, x, y = extended_gcd(54, 20)print(f"gcd({54}, {20}) = {d}")print(f"{54}*({x}) + {20}*({y}) = {54*x + 20*y}")# 例: 111x + 30y = gcd(111, 30) = 3d, x, y = extended_gcd(111, 30)print(f"gcd({111}, {30}) = {d}")print(f"{111}*({x}) + {30}*({y}) = {111*x + 30*y}")```