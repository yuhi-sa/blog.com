---
title: "[Python]ElGamal cryptography on elliptic curves"
date: 2020-12-23T15:17:23+09:00
draft: false
tags: ["Algorithm"] 
---
<!--more-->
# Key generation
1. Generate an elliptic curve $E/F_p$ and a Baze point $G$ of rank $l$. ($p,l$ are prime numbers)
2. Generate the secret key $x$ by random numbers and compute $Y=xG$ on $E$.

Secret key $x$, open key $E,G,Y$

# Encryption
Let $m$ be the message to be sent.
1. Generate $r$ as a random number and compute $U=rG=(u_x,u_y)$.
2. Using the public key $Y$,   
compute $V = xU =(v_x,v_y)$ and $c=v_x\oplus m$.  
The $\oplus$ is an exclusive or.
3. Send $(U,c)$ as a ciphertext.

# Eecryption
1. $V=xU=(v_x,v_y)$,  
$m=v_x\oplus c$

## Simplified Python Implementation

**[WARNING]**
The following program is a highly simplified implementation for understanding the basic concepts of Elliptic Curve ElGamal encryption. It uses extremely inefficient and insecure methods for modular inverse calculation and scalar multiplication. **It is absolutely NOT suitable for any real-world cryptographic applications.**

```python:elgamal_ecc_simple.py
# --- Parameter Settings (Very small prime field elliptic curve) ---
# y^2 = x^3 + ax + b (mod l)
a = 0
b = 1
l = 5 # Modulus (prime number)

# Base point G
g = [2, 2]

# --- Key Generation ---
# Private key (should be a large random number in practice)
private_key = 3

# --- Utility Functions ---
def mod(x, y):
    """Calculates the positive modulus."""
    return x % y

def inv_mod(x, y):
    """
    Calculates the modular multiplicative inverse (inefficient brute-force implementation).
    For prime y, Fermat's Little Theorem (x^(y-2) mod y) is more efficient.
    Extended Euclidean algorithm is generally used.
    """
    for i in range(1, y):
        if (x * i) % y == 1:
            return i
    return -1 # Not found

def point_double(p):
    """Doubles a point on the elliptic curve (P + P)."""
    # Slope s = (3*px^2 + a) / (2*py)
    s_num = 3 * p[0] * p[0] + a
    s_den = 2 * p[1]
    s = mod(s_num * inv_mod(s_den, l), l)
    
    # Coordinates of the new point
    x = mod(s * s - 2 * p[0], l)
    y = mod(s * (p[0] - x) - p[1], l)
    return [x, y]

def scalar_mult(k, p):
    """
    Calculates scalar multiplication k * P (inefficient repeated addition).
    In real cryptography, the "double-and-add" method, which applies repeated squaring
    (binary method) to point addition, is used.
    """
    # Note: This simplified implementation calculates 2^k * P, not k * P.
    # This does not meet the requirements for ElGamal encryption.
    # A correct k * P calculation requires implementing a point addition function
    # and a proper scalar multiplication algorithm like double-and-add.
    # This code works for demonstration purposes only with small fixed values of k.

    res = p
    for _ in range(k - 1):
        res = point_double(res)
    return res

def encrypt(G, Y, m):
    r = 3 # Should be a large random number in practice
    U = scalar_mult(r, G)
    V = scalar_mult(r, Y)
    # Mask message with XOR
    c = V[0] ^ m # Use x-coordinate
    return U, c

def decrypt(U, c, key):
    V = scalar_mult(key, U)
    m = V[0] ^ c # Use x-coordinate
    return m

def main():
    # Calculate public key Y = xG
    public_key = scalar_mult(private_key, g)
    print(f"Private key x: {private_key}")
    print(f"Public key Y: {public_key}")
    
    # Plaintext
    message = 4
    print(f"Plaintext m: {message}")
    
    # Encryption
    U, c = encrypt(g, public_key, message)
    print(f"Ciphertext (U, c): ({U}, {c})")
    
    # Decryption
    decrypted_message = decrypt(U, c, private_key)
    print(f"Decrypted message: {decrypted_message}")

if __name__ == "__main__":
    main()
```
